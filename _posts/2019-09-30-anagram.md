---
layout: post
title: "anagram 문제"
comments: true
---



```java
anagramCheck("abcd","bcad");
anagramCheck("abcd","ecad");


public static boolean anagramCheck(String first, String second) {
    boolean result = false;
    return result;
}
```
위의 문제에 대해서 손코딩을 해야했습니다.
아무것도 주어지지 않은 상태라서, 안전하게 기본문법만으로 코딩했습니다.
(긴장해서 아무생각도 나지 않았다는게 더 정답..)

```java
  public static boolean anagramCheck(String first, String second) {
        int firstLength = first.length();
        int secondLength = second.length();

        if (firstLength != secondLength) {
            return false;
        }

        char[] firstChar = new char[firstLength];
        char[] secondChar = new char[secondLength];

        for (int i=0;i<firstLength;i++) {
            firstChar[i] = first.substring(i, i + 1).charAt(0);
        }

        for (int i=0;i<secondLength;i++) {
            secondChar[i] = second.substring(i, i + 1).charAt(0);
        }

        int check = 0;
        for (char firstA: firstChar) {
            for (char secondB: secondChar) {
                if (firstA == secondB) {
                    check++;
                }
            }
        }

        return check == firstLength;
    }
```

다음과 같이 작성했습니다.
실제 손코딩에서는 charAt(0) 를 빠트린거랑, for문안에 안전장치로 if문을 하나 더 쓴거 빼고는 실제 손코딩했던 것과 동일한 로직입니다.

실제 원했던 것은 Stream 을 사용하여 코드를 간략하게 작성해야하는 것이 아닌가 싶어,
해당 Stream 으로 어떻게 읽기 편하게 작성해야하는지 공부(연습)해 보았습니다.

우선 기억이 안났던, toCharArray 메소드를 사용하여, char 로 변환해서 처리했습니다.

```java   
  public static boolean anagramCheck(String first, String second) {
      char[] fisrtChar = first.toCharArray();
      char[] secondChar = second.toCharArray();
      Arrays.sort(fisrtChar);
      Arrays.sort(secondChar);
      return new String(fisrtChar).equals(new String(secondChar));
  }
```

30 라인의 길이가 10라인까지 줄어들었습니다.
이펙티브 자바에서는 strem을 사용해서 처리하는 로직이 있는데,
해당 로직은 Stream<String> 에 담은 후에 처리하는 부분으로,
실제 해당 로직을 적용하는 것은 배보다 배꼽이 더 커보였습니다.

최종적으로 위의 줄인 로직을 기반으로 변경한 람다함수는 다음과 같습니다.
```java
public static boolean anagramCheck(String... list) {
    long count = Stream.of(list)
            .map(String::toCharArray)
            .peek(Arrays::sort)
            .map(String::valueOf)
            .distinct()
            .count();
    return count == 1;
}
```
넘어온 list 를 Stream에 담습니다. map 에 toCharArray를 담은 후 peek 로 ArrayList를 sort합니다.
다시 map으로 sort 된 값을 다시금 string으로 변환합니다.
distinct로 중복된 값을 제외한 후 count()를 샙니다.
만약 char로 정렬되지 않을 경우, count는 1이 아니게 됩니다.

계속 공부를 해야한다는 걸 다시금 느낍니다.
